<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Compactador + TOTP (Codificar/Decodificar)</title>
<style>
body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071029;color:#e6eef8}
.card{background:#081427;padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
input,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid #0b3552;background:#061427;color:#dbeafe;margin-bottom:6px}
button{background:#0ea5e9;color:#022035;border:none;padding:6px 12px;border-radius:8px;cursor:pointer;margin-top:4px;margin-right:4px}
pre{background:#021029;padding:12px;border-radius:8px;overflow:auto;white-space:pre-wrap}
label{font-size:13px;color:#9fb4d6}
.muted{color:#9fb4d6;font-size:13px}
.hidden{display:none;}
</style>
</head>
<body>

<div class="card" id="encodeScreen">
  <h2>Codificador BigInt + TOTP</h2>
  <p class="muted">Digite o texto que deseja codificar.</p>
  <textarea id="inputText" placeholder="Digite ou cole o texto aqui..."></textarea>
  <button id="encodeBtn">Codificar</button>
  <button onclick="showScreen('decodeScreen')">Ir para Decodificador</button>
  <h3>Resultado</h3>
  <pre id="encodeResult">Nenhum dado ainda.</pre>
</div>

<div class="card hidden" id="decodeScreen">
  <h2>Decodificador BigInt + TOTP</h2>
  <p class="muted">Informe o mixedBigInt (hex) e o código TOTP do Authenticator para reconstruir o texto.</p>
  <label>mixedBigInt (hex)</label>
  <input type="text" id="mixedHex" placeholder="Ex: 435320444e41...">
  <label>Segredo TOTP (base32)</label>
  <input type="text" id="totpSecret" placeholder="Ex: ABCDEFGH23456789...">
  <label>Código TOTP (6 dígitos)</label>
  <input type="text" id="totpCode" placeholder="Ex: 123456">
  <button id="decodeBtn">Decodificar</button>
  <button onclick="showScreen('encodeScreen')">Ir para Codificador</button>
  <h3>Resultado</h3>
  <pre id="decodeResult">Nenhum resultado ainda.</pre>
</div>

<script>
const B = 256n;
const BASE32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

function showScreen(id){
  document.getElementById('encodeScreen').classList.add('hidden');
  document.getElementById('decodeScreen').classList.add('hidden');
  document.getElementById(id).classList.remove('hidden');
}

function textToBytes(str){ return Array.from(new TextEncoder().encode(str)); }
function bytesToText(bytes){ return new TextDecoder().decode(new Uint8Array(bytes)); }
function bigIntToBytes(v){
  if(v===0n) return [0];
  const out=[];
  let cur=v;
  while(cur>0n){ out.push(Number(cur%B)); cur=cur/B; }
  return out;
}
function bytesToBigInt(bytes){
  let v=0n;
  for(let i=0;i<bytes.length;i++) v += BigInt(bytes[i])*(B**BigInt(i));
  return v;
}

function base32Encode(bytes){
  let bits=0,value=0,output='';
  for(const b of bytes){
    value=(value<<8)|b; bits+=8;
    while(bits>=5){ output+=BASE32[(value>>(bits-5))&31]; bits-=5; }
  }
  if(bits>0) output+=BASE32[(value<<(5-bits))&31];
  return output;
}

function base32Decode(str){
  const cleaned = str.replace(/=+$/,'').toUpperCase();
  let bits=0,value=0,out=[];
  for(const ch of cleaned){
    const idx=BASE32.indexOf(ch); if(idx===-1) continue;
    value=(value<<5)|idx; bits+=5;
    if(bits>=8){ out.push((value>>(bits-8))&0xFF); bits-=8; }
  }
  return new Uint8Array(out);
}

async function hmacSha1(keyBytes,msgBytes){
  const key = await crypto.subtle.importKey('raw',keyBytes,{name:'HMAC',hash:'SHA-1'},false,['sign']);
  const sig = await crypto.subtle.sign('HMAC',key,msgBytes);
  return new Uint8Array(sig);
}

function intToBytesBE(num,length){
  const out = new Uint8Array(length);
  for(let i=length-1;i>=0;i--){ out[i]=Number(num&0xFFn); num>>=8n; }
  return out;
}

async function generateTotp(secretBase32,forTime=Math.floor(Date.now()/1000),step=30,digits=6){
  const key = base32Decode(secretBase32);
  const counter = BigInt(Math.floor(forTime/step));
  const msg = intToBytesBE(counter,8);
  const hmac = await hmacSha1(key,msg);
  const offset = hmac[hmac.length-1]&0x0f;
  const code = ((hmac[offset]&0x7f)<<24)|((hmac[offset+1]&0xff)<<16)|((hmac[offset+2]&0xff)<<8)|(hmac[offset+3]&0xff);
  return (code%(10**digits)).toString().padStart(digits,'0');
}

async function derivePrimeFromSecret(secretBase32){
  const key = base32Decode(secretBase32);
  const hash = await crypto.subtle.digest('SHA-256', key);
  const hashBytes = new Uint8Array(hash);
  let p = 0n;
  for(let i=0;i<12;i++) p = (p<<8n)+BigInt(hashBytes[i]);
  p |= 1n; 
  if(p<3n) p+=3n;
  return p;
}

// --- Codificador ---
document.getElementById('encodeBtn').onclick = async ()=>{
  const text = document.getElementById('inputText').value || '';
  if(!text){ alert('Digite algum texto'); return; }

  const bytes = textToBytes(text);
  const originalBigInt = bytesToBigInt(bytes);

  const secretBytes = new Uint8Array(20);
  crypto.getRandomValues(secretBytes);
  const secretBase32 = base32Encode(secretBytes);

  const prime = await derivePrimeFromSecret(secretBase32);
  const mixedBigInt = originalBigInt * prime;

  document.getElementById('encodeResult').textContent = 
`mixedBigInt (hex): ${mixedBigInt.toString(16)}
TOTP Secret (base32): ${secretBase32}
Use este TOTP em seu app Authenticator.`;
};

// --- Decodificador ---
document.getElementById('decodeBtn').onclick = async ()=>{
  const mixedHex = document.getElementById('mixedHex').value.trim();
  const secretBase32 = document.getElementById('totpSecret').value.trim();
  const totpCode = document.getElementById('totpCode').value.trim();

  if(!mixedHex || !secretBase32 || !totpCode){
      alert('Preencha todos os campos.');
      return;
  }

  const mixedBigInt = BigInt('0x'+mixedHex);
  const now = Math.floor(Date.now()/1000);
  let valid=false;
  for(let delta=-1; delta<=1; delta++){
      const t = now + delta*30;
      const code = await generateTotp(secretBase32,t);
      if(code===totpCode.padStart(6,'0')){ valid=true; break; }
  }
  if(!valid){ alert('Código TOTP inválido'); return; }

  const prime = await derivePrimeFromSecret(secretBase32);
  const originalBigInt = mixedBigInt / prime;
  const bytes = bigIntToBytes(originalBigInt);
  const text = bytesToText(bytes);

  document.getElementById('decodeResult').textContent = text;
};
</script>
</body>
</html>
